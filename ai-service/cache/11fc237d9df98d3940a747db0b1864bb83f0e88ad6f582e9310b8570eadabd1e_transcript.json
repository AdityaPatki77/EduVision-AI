{
    "transcript": "If you're building a backend using JavaScript, then chances are you're going to be using Express.js. And in this video, I'm going to teach you everything you need to know about Express, including a few features I haven't seen in any other tutorials. Let's get started. Now, welcome back to WebDev Simplified. My name is Kyle and my job is to simplify the web for you so you can start building your dream project sooner. And by the end of this video, you're going to be an ExpressJS master. Now, to get started with Express.js, you're going to need to have Node installed. So, if you don't already have Node installed, make sure you check out the video I'll have linked in the cards and description. But once you have that done, just run npm init-y. That's going to set up a basic package JSON for you, as you can see right here. And this is where we're going to install all of our different libraries we're going to use. In our case, the main library we care about is called Express. So, let's type in npmi Express. That's going to install the Express library. You can see for this tutorial we're using version 4, but version five is currently in alpha. I've checked it out and everything in this tutorial is going to work for both version 4 and five. So it really doesn't matter what version of Express you're using. Now one other package I want to install just to make our development a lot easier is going to be a package called Nodemon. And we're going to save this as a dev dependency. So type in npmi-savedev nodemon. And what this is going to allow us to do is really easily restart our server anytime we make changes because normally you have to close your server, restart it manually. This will just do it automatically. So to set that up, let's create a script called dev start inside this scripts section. And this is just going to run the command nodemon. And then we're going to call it with our file which is called server.js. This is a file we're going to create right now. Server.js. And this is where we're going to put all of our server code. If we run the command npm rundev start, what's going to happen is it's going to run all the code in our server.js. And that's just because of this dev start right here we created. Then when we make changes and we save this, you can see it's logging that out down here. And it's automatically rerunning our server file. So now we just kind of have the basic setup. The first thing I want to do is to create our actual express server, which is really easy to do. First we need to require that Express library we downloaded. So we're just going to come in here and we're going to require express. Then to set up our actual server, we're going to essentially create an app variable which is just by calling this express function. So by calling express as a function, we create an application which allows us to set up our entire server. Then to make our server actually run, we can say app.listen and we pass it in a port number. So we're saying, hey, our app right here, our server is listening on port 3000 for a bunch of different requests. So now if we save that, we now have an app running on port 3000. And over here you can see we have localhost 3000 open. So if I refresh this page, you can see it's running our server and it says cannot get slash. All that's saying is that our application doesn't have any route set up. So when we try to get this index route, which is just slash, it's saying it can't find this route. Now this is pretty much where the entire bread and butter of express.js comes in is where you set up different routes. So the easiest way to set up a route is just say app dot and then we're going to be able to call different methods. For example, to make a git request, we can do a get route. A post request is going to be post. We have put, we have delete, and pretty much any HTTP method that you can think of is going to be available, but the main ones you're going to deal with are get, post, put, delete, or patch. In our case, we want to make a git request for the URL at slash. So, the way this function works is the first parameter you pass to it is going to be the path. In our case, we're just doing it at our root path, which is just a slash here. And then the second parameter is a function. And this function takes three different parameters. The first is a request, the second is a response, and the final parameter is this next function. In our case, 99.9% of the time when you're creating a route like this, you don't care about next. So, we're going to remove that. And we really only care about our request and our response. And you can call these whatever you want. But req and res are pretty standard naming conventions. Then inside of this function, we're just going to run code whenever we try to access this URL. So, we can just say console.log here. And then, in order to send data back down to the user, we need to send something along with our response. So, as you can see, there's a bunch of different methods we can use with this response, but the main methods you're going to use are sending information to the user. So, we can use send, which is just going to send down whatever we pass into it. It's pretty generic. So, we can send down, for example, the string hi. Now, if we refresh our page, you can see it logged out here in our console, which means it ran this code and we sent the response high down to the user. So, we've actually created a route at our index here, this / route. And whenever someone makes a getit request to that route, which happens when they navigate to that URL, it's going to send down the information hide to that user. Now, for the most part, send is not something you're going to use very often. It's great for testing purposes, but since sent is so generic, generally you want to use a more specific thing. So, one other thing we could do with our response is we could send down a status. So, we could say send status and we could pass in an HTTP status code. If you're not familiar with the status codes, I have a full video I'll link in the cards and description for you. Check them out. But essentially we could send down the code 500 for example and that means there was an error on our server. Now if we save and refresh you can see it sent down that status code of 500 and it just says internal server error right here. So if we inspect our page and we go over to the console you can see it says failed to load. The server responded with a status of 500. So we actually are able to send down different status codes to the user. Generally though when you're trying to send a status you probably want to send a message with it. So we can call just status here and we can pass it in the code for example 500 and then we can chain on another message such as send and we could just send high down. Now if we refresh it still says hi as the text but if we inspect and go to our console you can see we're getting that 500 error which is what we want. So we can chain together statuses with other things such as sending down a text string and that way we can do a status and a text string or more commonly you'll want to send down some JSON. So we can call thejson method and we can pass it in some JSON that for example says message error. And now when we save and refresh it sent down a JSON message. And the important thing is is this is actually JSON code being sent down. So if you're using this inside of some type of API and you want to send JSON to your client, this is going to be the best way to do that. And if you don't care about the status, for example, you want the status to be a default success, we'll just do res.json like this. Now we save and refresh. If we check our console, you'll notice we no longer get any errors because the status is a successful 200 status. Now, another thing you may want to do is actually send down a file to the user to download. Really easy way to do that is we just say res.d download and we pass it the path to the file we want. So, for example, if we want to download the exact file we're in, our server.js file, well, we can just send this down to the user like this. And when I refresh my page, you're going to see here that it's going to pop up a information for me to download this. I can click save and it's going to download that file directly to my hard drive. Now, the final thing that we can do with our response that's important is going to be rendering out an HTML file. And that's what you're going to be doing most of the time. You're either going to be sending down some JSON or you're going to be rendering a file. And to render a file, you just use the render method and then you pass it the path to the file that you want to render. So, let's say we want to render an index file. So, we're just going to pass down index. Now, in order to set up our application to actually work, first of all, we need to tell our app where these files are. And by default, all of your view files are going to live inside of the folder called views. So we create a file called views. And we just inside of here create an index.html file. And we just populate this with some boilerplate that says hello. Save this. Save this and refresh. You'll see that actually nothing works like we wanted to. We're getting an error that just says no default engine was specified and no extension was provided. The reason we're getting that error is because we don't actually have a view engine set up. The nice thing about using your server to output your views is that you can actually run your server code to generate the code inside of your views. For example, I could pass down information into this file. So to do that, there's a bunch of different view engines you can use, but we're going to be using E.JS as our view engine just because it's the one that's the most similar to HTML, but another popular one is called Pug. So to do that, let's just close out of our server and we're going to npmi a library called EJS. That is going to be for our view engine. And then we need to tell our application to use that view engine. So we can say app set and we want to set a variable. So the first thing we pass in is the name of the setting which in our case is view engine. And then we need to pass it in the view engine we're using which is EJS. This is just code you have to put in word for word if you want to use a view engine. If you use pug this would be pug for example instead but we're using EJS. Then you need to rename your file to have an E.JS extension at the end. So we're going to use EJS. And in order to get syntax highlighting for EJS, make sure you install the extension called E.JS language support in VS Code. Once you've done that, you'll be able to have your highlighting inside of here so you can actually run your server side code in E.JS and see all the highlighting. But now with all that done, if I restart our server, make sure we save everything and refresh. You can see we actually got that HTML page that says hello being sent down to the user by just passing in render here. Now, I did mention that you can pass information from your server down into your views. And to do that is this render takes a second parameter. The second parameter is just an object and you can pass anything you want to it. For example, we could say text is equal to world. And then inside of our view here, we could actually access that information. So to access information using EJS as your templating language, you need to put a less than symbol here, which is going to be just like an HTML, but instead you put a percent sign inside of here and then the equal sign. This right here is just saying, \"Hey, we're starting to run some code on the server, and I want you to run that code.\" And then with the equal sign here, it says output that code to the page. So inside here, we know could, for example, put 2 plus 2. Close that off with that percent sign and then the greater than symbol here. And that's saying, hey, run all the code between these symbols. And the equal says output that code to the page. So now if I save and refresh, you see it outputs four cuz it's running this code on the server. It gets the value of four and then outputs that to the page. Well, we want to pass down this text right here. So to access that variable, we just use the word text. Just like that. Now, if we refresh, it says hello world. And that text is coming from our server right here and we're accessing it inside of our client. Now, many times though when you are doing this type of server client communication, this variable text may or may not be defined. For example, maybe you didn't actually pass text inside of here and you passed, you know, something else. You know, we'll say text 2 3 4 2 3. Now, when we save and refresh, we're going to get an error. As you can see, it's giving us error. Text is not defined. And that's because we never actually passed text down inside of here. So, to get around that error, we could just say locals.ext. And that's because locals is always going to be defined. And then we're trying to access the text property. And this text property is just going to be anything we pass down here. So locals is essentially this object is just all the information we pass down to render inside of here. And it's always going to be defined. But text will just be undefined. So when we save this and refresh, you'll notice it prints nothing. And that's cuz text is not defined. So we could default it to say something like default. So now you can see if we don't pass in the text, it's going to be default. But if we change this to actually pass down our text, you'll now see that it actually prints out the correct world which we passed down. So this locals trick is a really good way to get around the fact that sometimes your variables will be defined inside of your server and sometimes they won't be. So far we've talked about all the different ways you can render out content to the screen. We've talked about rendering JSON, which is really common for APIs. Talked about rendering HTML, which is going to be common for a full stack web application. We talked about downloading different files. But you notice that we have all of our routes being defined in this server.js. And you can imagine if we have hundreds of different routes in our application, this file would become huge and really difficult to deal with. And that's why Express thought about this and they implemented the idea of a router. And a router is essentially a way for you to create another instance of your application that is its own little mini application that has all of its own logic applied to it. And then you can kind of just insert it into this main application. So what I want to do is I want to create two simple routes here. We're just going to say app.get get and we want to go to a / users path and remember that takes in a request and it's going to take in a response and then we're going to create another app.get get. And this one's going to go to slash users slash new to generate like a new user form. And this slash users is just going to list out all of our users. And again, this takes in that function which has a request and a response just like all of our other git methods here. And like I said, you could do post, you could do delete, and so on. We're going to get to that later, but for now, we're just doing get routes. So, you'll notice one thing interesting. These are all routes related to our user. And for now, let's just say res.end. And this is just going to be user list. And this right here is going to resz.end user new form. So if we go up here to slash users, you can see we get the user list. And if we go to / users/ new, we get the user new form. That works fine. But it would make more sense if we took all the code related to our users and put that inside of its own file. That way it's kind of encapsulated in its own area. It all is in its own section. And then we can just kind of import that into our main application that we have here. So to do that, generally the standard you're going to use is creating a folder called routes. You can really call this folder whatever you want, but the general standard is to call it routes because we're creating a index for all of our different routes. And we're going to create a file called users.js. This is going to contain all the routes for our user file. So let's just go into our server, take all those user routes, we're going to copy them out and put them into our users.js. And now in order to set up essentially a mini application, our own little router, what we need to do is import express. So we'll say const express is equal to requiring express. And then we can create a router. And this router is like an application that we've done here where we have our app, but it's like a mini app that's entirely on its own. And it just lives inside of this main application. This essentially means the stuff that we set up on this router is kind of going to be independent from the main router. And you'll see about that when we talk about middleware a little bit later in this video. But to create a router, we just take express.outer. We just call this as a function. And the important thing to note is this is a capital R for the router. That gives us a router and the router works exactly the same as our app. The router has functions such as.get.post and so on. So we can just replace app with router and that's going to work exactly the same. But the nice thing about a router is we can nest it inside of a parent route. So as you notice all of our routes start with slash users. What we can do is we can say everything about this router starts with slash users. So we're just going to cut off the users part of all of our different things. So right now all we have is slash and slash new and we just know our router is always going to go slash users at the beginning. So in order to use this router let's just make sure we export this router from this file and then we can import that into our server up here. Let's just do it at the very bottom of our page. So we'll say const user router is equal to and we want to require that file that we just created which is from our routes folder / users. Now in order to link up these routes here that we just created into our main app we need to call app do. use and this is a function that has a lot of different use cases but the way we're going to be using it is for linking a route to a particular path. So the first thing we pass to this is going to be the actual path that we start our thing with. So you remember all these started with slash user. What we want to do is just start all of these with slash users. So we'll say / users is where we mount this router and we pass it our router which is our user router. Now if I save this and save this over here you'll notice if I refresh my page it works just fine just like it did before. But all of our routes for our user are defined inside of here. And we don't have to put slash user in front of all of these. And that's because in our server, we're saying, hey, anything that starts with slash users, add all of these different routes to the end of it. So we're going to have a slash users that ends with a slash. And we're going to have a slash users that ends with slash new. That way we can kind of have that nesting without repeating that naming all over the place. This is a great practice to get into is just making sure all of your different routes are defined in these router files. Then you just use them throughout your application. So, for example, if you had a post section, you could just say post. This is going to be your post router. And, you know, you could copy this post router here. And you could get this from like a post file, for example, if this file existed. And you could do this for all of the different routes in your application. And it's going to be super clean. All of your code in your server.js. And each route file is going to be all the code for your individual routes. Now, the next thing I want to talk about is a few different ways you can kind of clean up how your routes are going to look. This both works if you call it on the app variable or if you call it on your router. We're just going to show it in the router instance because it's going to make the most sense to do all of these in router files. So if you have a particular user route like this, you may have routes like getting all the users. You want to get a form for a new user. You probably want to be able to create a user. So generally you're going to use a post request for that. So if we post to slash users, which in our case is just slash here. That's going to be essentially for creating a new user. Again, taking in a request and a response. And for now, I'm not going to worry about filling in this code. We'll just say res.end send create user for now. Another thing that you're probably going to want to do is be able to access an individual user. So we'll say router.get and we want to access a user based on the ID of that user. Well, we don't know what all the IDs of our users are right away. You know, we can't say like slash 1 slash2 slash3. Instead, we want to make it so that this piece of code is dynamically determined by the URL. So if we go to user slash one, for example, slash user slash 1. We want this to work. We want slash2 slash3 slash4 slash24. All of these routes we want to be valid. So in order to create a dynamic parameter, essentially a parameter in your URL that can be anything, you start it with a colon and then you put the name of the parameter. In our case, we'll call it ID. So this is saying get any route that starts off with / users because this is inside of our users router and then has any code at all afterwards, which we're going to declare as our ID. If we do that, then let's get our request and our response. And we want to say, you know, we'll just say res.end user getit. And this is going to be for getting an individual user. And in order to access this parameter, we get it from request.params. And then we can just say do ID because that's what we called this parameter right here. If we called this something like user ID, this would be user ID down here. It really depends on what you name this inside of your parameter. So if you start something with a colon, that's just saying this is a dynamic parameter. So we could just send down that information. We could say get user with id and we could pass it in that request.params do id. So now what we can do is we can go to slash users /2. This is saying hey get the user with ID2. If I go to slash users 51 get the user with the ID of 51. It's pulling that number directly from the URL. A really important thing to note though is when you're using dynamic parameters like this, if you have another parameter such as this get new and you put it below this dynamic ID right here, what's going to happen is everything goes from top to bottom inside of express. So it's going to read this route first and it says, hey, does this match an empty slash route? Obviously user 51 does not. It's not a post request, so we skip this. We're saying, hey, does it match get where anything comes after it? Well, we say / user 51. 51 is this ID. So, it's going to call this code here. But if we change this here to slash new instead, and I just save over here and I refresh the page, you're going to know it's trying to get a user with the ID of new. And that's because again, it's going from top to bottom. It says, does slash new match this? No, it doesn't match this. But it does match this because new is just an ID. It says it doesn't care what that code is. It's just saying new works as an ID. So, we're going to get the user with the ID of new. That's why if you have a route like slash new that's static, make sure you always put it above your dynamic routes because that way when we're going top to bottom slash new is going to match this route right here. So now if I refresh, we're getting our new form instead of getting put all the way inside of here with our get user with ID. Now let me just copy this route here a couple times because almost always when you're going to be creating routes, you're probably going to create a put route that allows you to update a user based on an ID. So we're going to say update user with this ID and we're also going to create a delete route which is going to allow us to delete a user with a particular ID. So you'll notice that these three routes are almost exactly the same. They have the exact same path to all of them and they're all doing a request and response. The only difference is one's a get, one's a put, and one is a delete. One really nice thing with Express is they know that this pattern is really common. So instead they created another method called the route. And this router.oute route. What it is, you pass it the path, which in our case is this slash id, and then you can chain together all your git, put, delete, and so on request. So, we could say.getit, and this is going to take in all the code for our git. So, let's just copy this code and paste it inside of our gget. Then, we can chain on apost to the end of this, or in our case, it's going to be aput. And we'll copy all of our code from our put request, paste it into there. And then we add the exact same thing for delete. So we'll say delete. We'll paste in all of our code for deleting a user. And now you can see we have a route which is defined as like slash ID over here. And we have a get request, a put request, and a delete request that's going to respond to this individual route right here. This code right here is exactly the same as the code down here. The real main difference is that we only had to define our route in one location and then all these other requests are going to be matching that route. So if we have a get request for that route, it does this code. Put request does this code and delete request does this code. It just kind of cleans up your code a little bit which is really nice. Now the next thing I want to talk about is going to be related to these params and that is a function on our router which is called param. This param function is really cool and something that almost nobody ever talks about. Essentially param this function is going to run anytime it finds a param that matches the name you pass in. So we're saying hey whenever you find a parameter with the name of ID I want you to run this function. And this function is going to take request and response just like anything else, but it's also going to take a next property. And then it's also going to take the value of the thing. In our case, the ID itself. And what this function is going to do is say, hey, whenever you go to a route that has an ID parameter, which all of these routes inside of here have that ID parameter, I want you to run this code with our request, our response, our next, and our ID. So for now, let's just console.log out the ID to see what happens. We can just come over here. We can say users /2. Click enter. And you'll notice over on our side, you can see that our page is infinitely loading. And right here, we're printing out two. So, we know we're logging out this two. And the reason that our page is infinitely loading is because this router.param when it finds that param, it runs the code inside of it. But it doesn't actually run any other code unless we call this function next. The way that this next function works is it's saying, hey, if I call this function, run the next thing in line. This is because param right here is essentially a type of middleware. And middleware inside of Express is stuff that runs between the request being sent to your server and the actual response being returned to the user. So as you can see here, we have all these get and put and delete request. These are all the responses being sent to the user. And middleware is stuff that runs before this section. So our param right here is running first. And all we're doing is logging out the ID. In order to run the next thing in line, which in our case is this get right here, we need to call this function next. Now, if I save that and I just refresh our page, you can see it's printing out get user with ID because we're going on to the next piece of middleware. And that's perfect. That's exactly what we want to do. Now, instead of just logging out the ID, what I want to do is I want to get the user with that ID. So, let's just come in here. We're going to get an array of users. And I'll just copy this over actually so I don't have to type this out. And we just have two users. One has the name of Kyle and one has the name of Sally. And what I want to do is I just want to take our request and I'm going to set a random variable. We can call this whatever we want. I'm just going to say our user for our request I'm going to set equal to users and I want to get the user for that ID. So our ID is the index of that user. So right here I can just say ID of one which should be the index user one Sally here we're going to set request do user to that. Then inside of our get I'm just going to say console.log request do user and if I refresh you can see it prints out Sally to the screen. So what this params has allowed us to do is essentially say hey anytime we have an ID get it from our user. So right here we have a users variable. Get the particular user for that ID. Then continue on with the rest of our code. And we're just going to save that in request user. Then anywhere else we have our request object which is pretty much everywhere. We can access that user directly. So we can get the user and we're just printing them out. But we could do whatever else we wanted with that user. This saves us from having to write out a ton of code instead of each one of these parameters to get the user. It allows us to do it in one single place which is why this PAM is really cool. So this PAM is one version of middleware. But I want to talk a bit more about middleware because it's one of the most fundamental concepts inside of Express. And I actually have an entire video that covers it. I'll link in the cards and description for you if you want to go even more in depth. But essentially middleware, like I said, is code that runs between the starting of the request and the ending of the request. So a really common type of middleware that you might want to create is a middleware for logging out something. So let's just create a function called logger. And this is going to be a middleware function. So it takes in a request, a response, and a next. Every single piece of middleware takes request, response, and next. And they work exactly the same as like ourit. It takes a request and a response. And it also technically takes a next, but we never actually use this next function when we're doing like a get or a post, which is why you only ever really see next when you're creating middleware. Now, inside this logger, all I want to do is just say console.log, and we're just going to say request.or original URL. We're just going to print out the URL that this request comes from. And then we're going to call next. So now this logger right here currently is not being used but we can use this middleware by just saying app.use and we pass it in the function we want to use which in our case is logger. Now if we save and we refresh you can see it prints out slash users one. If we go to just you know the main page here it just prints out slash and all these other console logs. Let me just get rid of them so they're not in the way. Get rid of that one too. So now if I refresh you can see it just prints out the URL. No matter what I type in, for example, / users, it's just printing out that URL. And it's doing it on every single request. And that's because again, middleware runs from top to bottom. So what happens is start at the top of our page. The first middleware we insert is our logger. Then we create this getit request here. And then we set up our router for our users. So everything comes after this logger middleware, which means everything uses it. Now, if I were to move this below this get request here, you'll notice if I refresh the page here, it still does slash users. That's because our logger comes before our users router. But if I just access our index, you'll see we don't get anything printed out. And that's because this get request is defined before our middleware for our logger. Again, everything is top to bottom. So if you have a middleware that you want to use everywhere on all of your routes, always define it at the very top of your page. Or if you don't want it to be used everywhere, you can use it on individual endpoints. So let's get rid of that. Right now we have no logging anywhere. But something that's really nice is that we could say that this logger is only going to work on this app.git right here and nowhere else. So to do that, we can actually just pass multiple functions to app.git. So we can pass our logger in here and that's going to run first. So it's going to run our logger and then it's going to run this function next as long as we call the next function. So if we go to our slash page, it prints out our logging of slash. But if we go to anywhere else such as / users, you notice it doesn't print anything in the console. And that's because this logger is only on this app.git. And you know, I could put as many pieces of middleware in here as I wanted to. For example, I could have three separate loggers and all three of them are going to run in order. So if I go to that homepage, it should log out slash three separate times cuz it runs this logger at the beginning, then this one, and then this one. So if you have middleware you only want to apply to individual routes or individual endpoints, you can do it like this. Also, if I wanted, I can move this logger into the router for our users. So I'm just going to come into users.js, JS create that router or logger function down here and then at the top I can just say router use and I want to use the logger and that means that every single route defined on this router so all of our user routes are going to log themselves out. So if I go to / users it logs it out slash user one it logs out but if I go to the homepage you'll notice it doesn't log anything out and that's because this logger is only defined inside of the user router and nowhere else. There's actually quite a few builtin middleware into Express and one of the most common ones you're going to be using is for serving out static files, things like static HTML, CSS or JavaScript that you want to serve to the user. So inside of our server, let's say right here our app.git. Right now we're rendering out this index. EJS. Let's just say that this always is going to say hello world. And this is it's just static. It doesn't change ever. We don't really need to create a fullon blown route just to render out something that never changes. So instead, let's remove this completely. And what we want to do now is when we refresh this page, we want to serve a static index html file. Well, let's create a folder called public. You can call this folder anything you want, but public is like standard naming convention. We're going to rename this to index html and we're just going to drag that into the public folder that we just created. So now if we go into our server, we can say that we want to app.use and we want to use a middleware. And this middleware is express.static. This express.static static function takes the name of the folder where all of our static files are. In our case, we called this pulled folder public. So, we can just say express.static, pass it in the name public, and this is going to serve all of the files from our public folder exactly as we want. So, now if we refresh this, you can see it says hello world. That's because this is our index file. We create a folder called, for example, test. And inside of here, we're going to put a file called tt.html. And inside of here, let's just put a bunch of random text. What we can do is we can actually navigate to that page by saying /est/tt.html. Hit enter and it's just going to allow us to access that file directly from the public folder. So that's a super handy way to be able to render out just static HTML or if you have CSS or JavaScript, they're all going to go in that public folder. So you're going to need that in pretty much every application. Now the next instance where you're going to have some built-in middleware is actually going to be for parsing all the information sent to your server from like forms or JSON requests. So let me show you a little bit of an example inside of our users here. Let's go down to our git for our new. And here I want to render out a form. So we're just going to say render out new. And this is going to be users/ new. And we're just going to render out this page. So in our views, let's create that users/ new.js file. So it's in the users folder called new.js. I'm actually just going to copy in the code for this. Essentially, all that we're doing is we're creating a form. And on the form, our action is going to be making a post request to slash users. And inside here, you can see we have a post that goes to slash users, which right now just sends out create user. And we also have an import here that has a type of text. The name is first name. And then we have a button that submits that. And finally, we have a value here that's set to locals first name. So we can put in a placeholder value that starts out. So inside of here, if I wanted to, I could just say first name is equal to test. And that's going to be the value to start with. So if I go to slash user/ new, you can see we get first name. And that test is being put there. But if I leave this off, for example, it'll just leave this completely blank when I refresh the page. So now, let's just say I type in the first name Kyle and I click submit. You can see it's saying create user because it's doing this post here. But instead, I want to access that variable that I just posted up to the server from the form. Well, we have our request. We can access the body of that request and we could say first name. And that's because inside of new.js, we gave this input a name of first name. So whatever name your input has is going to match directly to whatever you get on the body. So let me just console.log this out for now. And otherwise we're just going to say res.endi. So now if I refresh, go back to user/ new and I just type this in, click submit, you'll notice we actually get an error. It says cannot read property first name of undefined. We're not able to access the body at all. And that's because by default express does not allow you to access the body. We need to use middleware to do that for us. So in our server we can just say app do use and we want to use the express URL encoded middleware. This allows us to access information coming from forms. So inside of here we also need to pass a object that has extended set to true. This is just base boilerplate code that we need to put in otherwise we're going to get a warning. So now if we save and we refresh this page click continue you're going to notice that down here it's printing out asf asdf which is the name we gave to our user. Now the final thing I want to do in this user.js JS is kind of write a little bit of code to emulate what would happen in a real world situation. So we're just going to say const is valid is equal to true. This is just a variable we'll change around to see if different scenarios work for what happens when we have a valid response and an invalid one. So then we can just say if is valid. So if this is a valid request, we want to create our user. So we can just say users, which is our variable down here with all of our users. We're going to push in a brand new user. And that brand new user is going to have a first name which is coming from request.body firstname. Just like that. And then what I want to do is redirect the user to the git page for that user they just created. So we could say response.redirect. And redirect just changes the URL completely. We're going to go to a brand new URL. So it's going to go to whatever URL we want. And in our case, we want to go to slash users slash. And we want to get the ID of the user, which just comes from our users array. We want to get the length and subtract one because that's going to be the brand new user we just created. And then essentially down in the else statement, what we can do is we can just console.log error and we can rerender out that form. So we'll say res.render and we want to go to users/ new and we want to pass down the first name first name that they tried to create this with request.body first name. And I'll show you why we do that in just a second. So on a valid request, let's go to /ash new up here. And we'll type in the name Kyle. Click submit. And you can see it says get user with ID2 because we created a brand new user with that ID2. And also if I just come in here and say console.log request user and I go back to that slash new and I just create another user. We'll call them John. Click submit. You can see down here it's printing out the user with the first name John. So we created the user. we're able to get the user and we're redirecting back to the page for that user. Now, if we change is valid to false and we run our code, let's just see exactly what will happen. So, we'll go to / user/ new, type in a bunch of code, click submit, and you'll notice down here, it prints out error and it redirects us back to this page and it puts in the actual text that we had previously. And that's working because of right here, we're passing the first name down. And instead of here, we're defaulting the value to the first name. If we didn't do this step and we just hit submit, you'll notice it blanks out the first name. This is just bad user interface. Generally, if user submits information, you want to populate that information back to the user, which is why you pass it down like this. Then when we click submit, even if it fails, it still has the information populated so they can change it and make it correct. Now, one other thing that you're probably going to commonly deal with is when you're posting JSON information to your server. So to be able to process JSON information, we just say app.express.json JSON and call that function. This does the exact same thing as URL encoded, but it works for whenever we make a JSON request. So, if you're making a fetch from the client to the server or you're calling an API, this is going to allow you to parse JSON information from the body. Now, the very final thing that I want to talk about is what happens when you have to deal with query parameters. So, for example, let's say up here we put a query parameter that says name equals and we'll just say Kyle. Hit enter. And what we want to do is we want to be able to access the actual name property from a user. So we have name equals Kyle and we want to get that name from the query string. That's actually really easy to do. We're on the slash route for our users. We can just say request.query and then dot whatever we passed in here. So we called it name. This is going to be whatever we pass up here as our name. So if we just do a quick console.log of that. Click save. And if we refresh this, you can see it's printing out Kyle down here, which is coming from our query parameters right here. If we change the name to something like John, you'll see now it is printing out John. So, we're able to get that information directly from the query string by using request.query. And that's all there is to Express. If you want to take your skills to the next level, I highly recommend checking out my full stack NodeJS course. It's completely free and linked over here. Also, I have a full middleware express guide which is going to be linked over here as well. And with that said, thank you very much for watching and have a good"
}